// Package flockerbot implements a simple IRC bot. To use it, populate a Bot struct and call Connect() on it.
// To send messages, use the SendString and SendStruct methods. For receiving messages, make sure the
// handler field is set. The handler function will be called on reception of messages, with the message
// struct as the parameter.
package flockerbot

import (
	"bufio"
	"crypto/tls"
	"errors"
	"io"
	"net"
	"sync"
	"time"

	"github.com/sorcix/irc"
)

const (
	// SocketWrite signals writing to socket
	socketWrite = iota
	// SocketRead signals reading from socket
	socketRead
)

var (
	// ErrTimeout signals timeout
	ErrTimeout = errors.New("Bot: Timeout")
)

// Bot implements the bot
type Bot struct {
	ConnectAddress string // where to connect to. IP:Port.
	User           string // Username for USER command.
	Nick           string // Nickname for NICK command.
	Password       string // Password for authentication. If empty, no authentication will be used.
	IsServer       bool   // Register as server, not client. User field is used as the server name.
	Timeout        int64  // Connect and ping timeout.
	TLS            bool   // connect via TLS

	Handler          func(msg *irc.Message) // Handler for messages. The handler will not be called for PING, 001 and 443 messages.
	ConnectedHandler func()                 // Handler that is called on connect

	activeNick    string              // The actual active nick.
	err           error               // Last error.
	nickCount     int                 // counter for nick modification if nick is in use
	socket        net.Conn            // connection
	socketChan    chan *channelString // Message stream
	userSet       bool                // if the user has been set
	connected     bool                // true as soon as we are connected
	mutex         *sync.RWMutex
	autoReconnect bool // Should we autoreconnect?

	ErrChan chan error // Channel to send errors to
}

// ChannelString is the result of a read from a blocking reader
type channelString struct {
	Data string // Data to read/write
	Err  error  // If an error occured
	Dir  int    // Direction (read/write)
}

// SetAutoReconnect value
func (b *Bot) SetAutoReconnect(v bool) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	b.autoReconnect = v
}

func (b *Bot) isAutoConnect() bool {
	b.mutex.RLock()
	defer b.mutex.RUnlock()
	return b.autoReconnect
}

// CurrentNick returns the actual nick of the connection.
func (b *Bot) CurrentNick() string {
	b.mutex.RLock()
	defer b.mutex.RUnlock()
	return b.activeNick
}

// Connected returns true if the connection was successful.
func (b *Bot) Connected() bool {
	b.mutex.RLock()
	defer b.mutex.RUnlock()
	return b.connected
}

// Error returns the last error generated by Connect. To be used in goroutine scenarios.
func (b *Bot) Error() error {
	b.mutex.RLock()
	defer b.mutex.RUnlock()
	return b.err
}

// SendStruct sends a message.
func (b *Bot) SendStruct(msg *irc.Message) {
	b.SendString(msg.String())
}

// SendString sends a string.
func (b *Bot) SendString(msg string) {
	b.socketChan <- &channelString{
		Dir:  socketWrite,
		Data: msg + "\r\n",
	}
}

// Disconnect the bot.
func (b *Bot) Disconnect() error {
	b.mutex.RLock()
	defer b.mutex.RUnlock()
	err := b.err
	b.socket.Close()
	return err
}

// ReplyTo returns a string containing where to reply to.
func (b *Bot) ReplyTo(msg *irc.Message) string {
	if len(msg.Params) > 0 {
		if msg.Params[0] != b.activeNick {
			return msg.Params[0]
		}
	}
	if msg.Prefix != nil {
		return msg.Prefix.Name
	}
	return ""
}

// Setup prepares the bot
func (b *Bot) Setup() {
	if b.mutex == nil {
		b.mutex = new(sync.RWMutex)
	}
}

// StayConnected keeps the bot connected
func (b *Bot) StayConnected() error {
	for {
		if !b.isAutoConnect() {
			return nil
		}
		if err, _ := b.Connect(); err != nil {
			return err
		}
	}
	return nil
}

// Connect the bot and go into main loop.
func (b *Bot) Connect() (err, loopError error) {
	defer func() {
		recover()
	}()
	var n int
	var tmpSocket net.Conn
	lastTime := now()
	b.nickCount = -1
	dialer := &net.Dialer{
		Timeout:   time.Second * time.Duration(b.Timeout),
		KeepAlive: time.Second * 15,
	}
	tmpSocket, err = dialer.Dial("tcp", b.ConnectAddress)
	if err != nil {
		b.setError(err)
		return err, nil
	}
	tcpSocket := tmpSocket.(*net.TCPConn)
	tcpSocket.SetKeepAlive(true)
	tcpSocket.SetNoDelay(true)
	if b.TLS {
		tlsSocket := tls.Client(tmpSocket, &tls.Config{
			InsecureSkipVerify: true,
		})
		err := tlsSocket.Handshake()
		if err != nil {
			b.setError(err)
			return err, nil
		}
		tmpSocket = tlsSocket
	}
	b.socket = tmpSocket
	defer b.socket.Close()
	b.socketChan = make(chan *channelString, 30)
	go b.socketReader()
	go b.ticker()
	outWriter := bufio.NewWriter(b.socket)
	b.sendPass()
	b.setNick()
	b.setUser()
SocketLoop:
	for m := range b.socketChan {
		if m == nil {
			if lastTime < now()-b.Timeout {
				err = ErrTimeout
				break SocketLoop
			} else {
				if lastTime < now()-60 {
					b.SendString("PING : 1")
				}
			}
			continue SocketLoop
		}
		switch m.Dir {
		case socketWrite:
			n, err = outWriter.WriteString(m.Data)
			if err != nil {
				break SocketLoop
			}
			if n < len(m.Data) {
				err = io.ErrShortWrite
				break SocketLoop
			}
			if m.Err != nil {
				err = m.Err
				break SocketLoop
			}
			err = outWriter.Flush()
			if err != nil {
				break SocketLoop
			}
		case socketRead:
			lastTime = now()
			if m.Err != nil {
				err = m.Err
				break SocketLoop
			}
			msg := irc.ParseMessage(m.Data)
			if msg != nil {
				if msg.Prefix != nil {
					if msg.Prefix.IsServer() {
						switch msg.Command {
						case "433":
							b.setNick()
						case "001":
							b.setConnected(true)
							if b.ConnectedHandler != nil {
								go b.ConnectedHandler()
							}
						default:
							if b.Handler != nil {
								go b.Handler(msg)
							}
						}
						continue SocketLoop
					}
					if b.Handler != nil {
						go b.Handler(msg)
					}
				} else {
					switch msg.Command {
					case "PING":
						b.SendString("PONG " + msg.Trailing)
					}
				}
			}
		}
	}
	b.mutex.Lock()
	defer b.mutex.Unlock()
	close(b.socketChan)
	b.err = err
	b.connected = false
	loopError = nil
	return nil, err
}

func (b *Bot) setError(err error) {
	if b.ErrChan != nil {
		go func() {
			b.ErrChan <- err
		}()
	}
	b.mutex.Lock()
	defer b.mutex.Unlock()
	b.err = err
}

func (b *Bot) setConnected(connected bool) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	b.connected = connected
}
