// Package flockerbot implements a simple IRC bot. To use it, populate a Bot struct and call Connect() on it.
// To send messages, use the SendString and SendStruct methods. For receiving messages, make sure the
// handler field is set. The handler function will be called on reception of messages, with the message
// struct as the parameter.
package flockerbot

import (
	"bufio"
	"errors"
	"io"
	"net"
	"time"

	"github.com/sorcix/irc"
)

const (
	// SocketWrite signals writing to socket
	socketWrite = iota
	// SocketRead signals reading from socket
	socketRead
)

var (
	// ErrTimeout signals timeout
	ErrTimeout = errors.New("Bot: Timeout")
)

// Bot implements the bot
type Bot struct {
	ConnectAddress string // where to connect to. IP:Port.
	User           string // Username for USER command.
	Nick           string // Nickname for NICK command.
	Password       string // Password for authentication. If empty, no authentication will be used.
	IsServer       bool   // Register as server, not client. User field is used as the server name.
	Timeout        int64  // Connect and ping timeout.

	Handler func(msg *irc.Message) // Handler for messages. The handler will not be called for PING, 001 and 443 messages.

	activeNick string              // The actual active nick.
	err        error               // Last error.
	nickCount  int                 // counter for nick modification if nick is in use
	socket     *net.TCPConn        // connection
	socketChan chan *channelString // Message stream
	userSet    bool                // if the user has been set
	connected  bool                // true as soon as we are connected
}

// ChannelString is the result of a read from a blocking reader
type channelString struct {
	Data string // Data to read/write
	Err  error  // If an error occured
	Dir  int    // Direction (read/write)
}

// CurrentNick returns the actual nick of the connection.
func (b *Bot) CurrentNick() string {
	return b.activeNick
}

// Connected returns true if the connection was successful.
func (b *Bot) Connected() bool {
	return b.connected
}

// Error returns the last error generated by Connect. To be used in goroutine scenarios.
func (b *Bot) Error() error {
	return b.err
}

// SendStruct sends a message.
func (b *Bot) SendStruct(msg *irc.Message) {
	b.SendString(msg.String())
}

// SendString sends a string.
func (b *Bot) SendString(msg string) {
	b.socketChan <- &channelString{
		Dir:  socketWrite,
		Data: msg + "\r\n",
	}
}

// Disconnect the bot.
func (b *Bot) Disconnect() error {
	err := b.err
	b.socket.Close()
	return err
}

// ReplyTo returns a string containing where to reply to.
func (b *Bot) ReplyTo(msg *irc.Message) string {
	if len(msg.Params) > 0 {
		if msg.Params[0] != b.activeNick {
			return msg.Params[0]
		}
	}
	if msg.Prefix != nil {
		return msg.Prefix.Name
	}
	return ""
}

// Connect the bot and go into main loop.
func (b *Bot) Connect() error {
	defer func() {
		recover()
	}()
	var n int
	lastTime := now()
	b.nickCount = -1
	dialer := &net.Dialer{
		Timeout:   time.Second * time.Duration(b.Timeout),
		KeepAlive: time.Second * 15,
	}
	tmpSocket, err := dialer.Dial("tcp", b.ConnectAddress)
	if err != nil {
		b.err = err
		return err
	}
	b.socket = tmpSocket.(*net.TCPConn)
	b.socket.SetNoDelay(true)
	defer b.socket.Close()
	b.socketChan = make(chan *channelString, 10)
	go b.socketReader()
	go b.ticker()
	outWriter := bufio.NewWriter(b.socket)
	b.sendPass()
	b.setNick()
	b.setUser()
SocketLoop:
	for m := range b.socketChan {
		if m == nil {
			if lastTime < now()-b.Timeout {
				err = ErrTimeout
				break SocketLoop
			}
			continue SocketLoop
		}
		switch m.Dir {
		case socketWrite:
			n, err = outWriter.WriteString(m.Data)
			if err != nil {
				break SocketLoop
			}
			if n < len(m.Data) {
				err = io.ErrShortWrite
				break SocketLoop
			}
			if m.Err != nil {
				err = m.Err
				break SocketLoop
			}
			err = outWriter.Flush()
			if err != nil {
				break SocketLoop
			}
		case socketRead:
			lastTime = now()
			if m.Err != nil {
				err = m.Err
				break SocketLoop
			}
			msg := irc.ParseMessage(m.Data)
			if msg != nil {
				if msg.Prefix != nil {
					if msg.Prefix.IsServer() {
						switch msg.Command {
						case "433":
							b.setNick()
						case "001":
							b.connected = true
						default:
							if b.Handler != nil {
								b.Handler(msg)
							}
						}
						continue SocketLoop
					}
					if b.Handler != nil {
						b.Handler(msg)
					}
				} else {
					switch msg.Command {
					case "PING":
						b.SendString("PONG " + msg.Trailing)
					}
				}
			}
		}
	}
	close(b.socketChan)
	b.err = err
	b.connected = false
	return err
}
